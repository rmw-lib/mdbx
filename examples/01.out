#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use anyhow::{Ok, Result};
use mdbx::prelude::*;
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
pub struct MDBX {
    __private_field: (),
}
#[doc(hidden)]
pub static MDBX: MDBX = MDBX {
    __private_field: (),
};
impl ::lazy_static::__Deref for MDBX {
    type Target = Env;
    fn deref(&self) -> &Env {
        #[inline(always)]
        fn __static_ref_initialize() -> Env {
            {
                let mut db_path = std::env::current_exe().unwrap();
                db_path.set_extension("mdb");
                {
                    ::std::io::_print(::core::fmt::Arguments::new_v1(
                        &["mdbx file path ", "\n"],
                        &match (&db_path.display(),) {
                            _args => [::core::fmt::ArgumentV1::new(
                                _args.0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                };
                db_path.into()
            }
        }
        #[inline(always)]
        fn __stability() -> &'static Env {
            static LAZY: ::lazy_static::lazy::Lazy<Env> = ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for MDBX {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
#[allow(non_upper_case_globals)]
pub struct Test {
    __private_field: (),
}
#[doc(hidden)]
pub static Test: Test = Test {
    __private_field: (),
};
impl ::lazy_static::__Deref for Test {
    type Target =
        ::mdbx::db::Config<'static, mdbx::r#type::Bin<'static>, mdbx::r#type::Bin<'static>>;
    fn deref(
        &self,
    ) -> &::mdbx::db::Config<'static, mdbx::r#type::Bin<'static>, mdbx::r#type::Bin<'static>> {
        #[inline(always)]
        fn __static_ref_initialize(
        ) -> ::mdbx::db::Config<'static, mdbx::r#type::Bin<'static>, mdbx::r#type::Bin<'static>>
        {
            MDBX.db(
                "Test",
                mdbx::flag::DB::MDBX_DB_DEFAULTS | ::mdbx::flag::DB::MDBX_CREATE,
            )
            .unwrap()
        }
        #[inline(always)]
        fn __stability() -> &'static ::mdbx::db::Config<
            'static,
            mdbx::r#type::Bin<'static>,
            mdbx::r#type::Bin<'static>,
        > {
            static LAZY: ::lazy_static::lazy::Lazy<
                ::mdbx::db::Config<'static, mdbx::r#type::Bin<'static>, mdbx::r#type::Bin<'static>>,
            > = ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for Test {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}
#[allow(non_snake_case)]
extern "C" fn _initTest() {
    lazy_static::initialize(&Test);
}
#[used]
#[allow(non_upper_case_globals)]
#[doc(hidden)]
#[link_section = "__DATA,__mod_init_func"]
static _initTest___rust_ctor___ctor: unsafe extern "C" fn() = {
    unsafe extern "C" fn _initTest___rust_ctor___ctor() {
        _initTest()
    };
    _initTest___rust_ctor___ctor
};
impl<'a> std::ops::BitOr<Test> for &'a ::mdbx::tx::Tx {
    type Output =
        ::mdbx::db::Db<mdbx::db::kind::One, mdbx::r#type::Bin<'static>, mdbx::r#type::Bin<'static>>;
    fn bitor(self, config: Test) -> Self::Output {
        ::mdbx::db::Db::new(self.0, config.dbi)
    }
}
impl Clone for Test {
    fn clone(&self) -> Self {
        *self
    }
}
impl Copy for Test {}
fn main() -> Result<()> {
    unsafe {
        {
            ::std::io::_print(::core::fmt::Arguments::new_v1(
                &[
                    "mdbx version https://github.com/erthink/libmdbx/releases/tag/v",
                    ".",
                    ".",
                    "\n",
                ],
                &match (
                    &mdbx_version.major,
                    &mdbx_version.minor,
                    &mdbx_version.release,
                ) {
                    _args => [
                        ::core::fmt::ArgumentV1::new(_args.0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(_args.1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(_args.2, ::core::fmt::Display::fmt),
                    ],
                },
            ));
        };
    }
    let t = std::thread::spawn(|| {
        let tx = &MDBX.w()?;
        let test = tx | Test;
        test.set([1, 2], [6])?;
        {
            ::std::io::_print(::core::fmt::Arguments::new_v1(
                &["test1 get ", "\n"],
                &match (&test.get([1, 2]),) {
                    _args => [::core::fmt::ArgumentV1::new(
                        _args.0,
                        ::core::fmt::Debug::fmt,
                    )],
                },
            ));
        };
        match test.get([1, 2])? {
            Some(val) => {
                let t: &[u8] = &val;
                {
                    ::std::io::_print(::core::fmt::Arguments::new_v1(
                        &["", "\n"],
                        &match (&t,) {
                            _args => [::core::fmt::ArgumentV1::new(
                                _args.0,
                                ::core::fmt::Debug::fmt,
                            )],
                        },
                    ));
                };
            }
            None => ::core::panicking::panic("internal error: entered unreachable code"),
        }
        Ok(())
    });
    t.join().unwrap()?;
    Ok(())
}
